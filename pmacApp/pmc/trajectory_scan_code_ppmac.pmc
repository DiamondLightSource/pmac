// *****************************************************************************************
// Set-Up
// *****************************************************************************************

// Set Initial Values
BufferLength = BuffLen                          // BuffLen defined in header file
BufferAdr_A = 0                                 // BufferAdr defined in header file
BufferAdr_B = 2 * BufferLength                  // each individual array holds 2 buffers
Traj_Status = Traj_StatusInitialised            // Traj_Status = 0
AbortTrigger = 0
Error = 0

// *****************************************************************************************
// Program
// *****************************************************************************************

Open PROG ProgramNum

Abs
FRAX(A,B,C,U,V,W,X,Y,Z)

Traj_Status = Traj_StatusActive                     // Traj_Status = 1: Reset values to defaults
AbortTrigger = 0
Error = 0
CurrentIndex = 0
TotalPoints = 0

CurrentBufferAdr = BufferAdr_A      // Set CurrentBuffer values to buffer A
CurrentBufferFill = BufferFill_A
CurrentBuffer = 0

PrevBufferFill = BufferLength       // Set PrevBufferFill to pass outer while loop condition

GoSub101                            // Check which axes are required
GoSub103                            // Set addresses for required axes
GoSub108                            // set all previous velocities to zero

While(AbortTrigger == 0 && Error == 0 && CurrentBufferFill > 0 && PrevBufferFill == BufferLength)
{
    CurrentIndex = 1
    // This loop ends when Current_* is at N-1 because then Next_* is at N
    While(AbortTrigger == 0 && Error == 0 && CurrentIndex < CurrentBufferFill)
    {
        GoSub102                            // Shift values through Next_* -> Current_* -> Prev_*
        GoSub104                            // Check time
        GoSub110                            // Move axes
        CurrentIndex = CurrentIndex + 1

    }

    GoSub102                                // Shift previous/current coordinates to N-1th/Nth points in buffer

    // Toggle buffer - Change address & specifier, set new buffer fill, reset previous buffer fill
    PrevBufferFill = CurrentBufferFill      // Update previous buffer fill - will exit while loop if it wasn't full
    If(AbortTrigger == 0 && CurrentBufferFill == BufferLength)
    {
        If(CurrentBuffer == 0)
        {
            CurrentBufferAdr = BufferAdr_B
            CurrentBuffer = 1
            CurrentBufferFill = BufferFill_B
            BufferFill_A = 0
        }
        Else
		{
            CurrentBufferAdr = BufferAdr_A
            CurrentBuffer = 0
            CurrentBufferFill = BufferFill_A
            BufferFill_B = 0
        }
        // Move to final point of buffer if next buffer has points
        If(AbortTrigger == 0 && CurrentBufferFill > 0)     // Do move with previous buffer N-1 and N and current buffer 1
        {
            CurrentIndex = 0                    // Reset to start of next buffer
            GoSub103                            // Update Next_* addresses to 0th point of next buffer
            GoSub104                            // Check time
            GoSub110                            // Move axes to final point of previous buffer
        }
        Else
        {
            // Move to final point if the scan wasn't aborted
            If(AbortTrigger == 0)
            {
                GoSub108                // Set velocity through final point to zero
                GoSub110                // Move axes
            }
        }
    }
    Else
    {
        If(Traj_Status == Traj_StatusActive) // Traj_Status == 1
		{
            // Move to final point if the scan wasn't aborted
            If(AbortTrigger == 0)
            {
                GoSub108                // Set velocity through final point to zero
                GoSub110                // Move axes
            }
        }
    }
}

Dwell 0                         // Stop program aborting before above lines are complete
// Traj_Status == 1: Set Idle Status if no error occurred
If(Traj_Status == Traj_StatusActive)
{
    Traj_Status = Traj_StatusIdle // Traj_Status = 2: Set program finished (Idle status)
}
Dwell 200                       // Ensure the driver receives an updated status before killing the program
Return

// Subroutine 1 ************************************************************************************
// Check that axes value is valid and activate required axes. The *_Axis values point to the bits of
// AxesParser and therefore represent axis activation
// *************************************************************************************************
N101:
    If(Axes > 511)
    {
        Traj_Status = Traj_StatusError // Traj_Status = 3
        Error = 1
    }
    Else
    {
        AxesParser = Axes   // Set bit parsed address to set required axes
    }
Return

// Subroutine 2 ************************************************************************************
// Shift coordinate buffer through// Current -> Prev and then Next -> Current
// *************************************************************************************************

N102:
    PVT_Time = Next_Time(CalculatedBase)
    UserFunc = Next_User(CalculatedBase)

    If(A_Axis == 1)
    {
        Current_A = Next_A(CalculatedBase)
        A_Vel = Next_A_Vel(CalculatedBase)
    }
    If (B_Axis == 1)
    {
        Current_B = Next_B(CalculatedBase)
        B_Vel = Next_B_Vel(CalculatedBase)
    }
    If (C_Axis == 1)
    {
        Current_C = Next_C(CalculatedBase)
        C_Vel = Next_C_Vel(CalculatedBase)
    }
    If (U_Axis == 1)
    {
        Current_U = Next_U(CalculatedBase)
        U_Vel = Next_U_Vel(CalculatedBase)
    }
    If (V_Axis == 1)
    {
        Current_V = Next_V(CalculatedBase)
        V_Vel = Next_V_Vel(CalculatedBase)
    }
    If (W_Axis == 1)
    {
        Current_W = Next_W(CalculatedBase)
        W_Vel = Next_W_Vel(CalculatedBase)
    }
    If (X_Axis == 1)
    {
        Current_X = Next_X(CalculatedBase)
        X_Vel = Next_X_Vel(CalculatedBase)
    }
    If (Y_Axis == 1)
    {
        Current_Y = Next_Y(CalculatedBase)
        Y_Vel = Next_Y_Vel(CalculatedBase)
    }
    If (Z_Axis == 1)
    {
        Current_Z = Next_Z(CalculatedBase)
        Z_Vel = Next_Z_Vel(CalculatedBase)
    }

    // All Prev <- Current <- Next shifts done so now
    // increment the 'next pointer'
    // Calculated base is the index into all 'Next' Arrays and
    // Current Index is incremented at each iteration
    CalculatedBase = CurrentBufferAdr + CurrentIndex
Return

// Subroutine 3 ************************************************************************************
// Assign coordinate pointers based on CurrentBufferAdr (The start address of Buffer A/B),
// BufferLength (length of the sub-buffers) and CurrentIndex (position of Next_* pointer within the
// sub-buffers). If the axis is not activated (see Subroutine 1), it won't be incremented and will
// remain pointing to the BlankAdr
// *************************************************************************************************

N103:
    CalculatedBase = CurrentBufferAdr + CurrentIndex
Return

// Subroutines 4-8 *********************************************************************************
// Calculate velocities for next move - 4: Master, 5: Prev->Current, 6: Prev->Next, 7: Current->Next
// 8: Zero velocity for final move
// Velocities are multiplied by 1000000 because the units of Time are microseconds and the units
// of velocity are EGUs/second in the PVT move definition
// *************************************************************************************************

N104:
    If(PVT_Time == 0)
    {                      // Set error and abort if demanded move time is zero
        Traj_Status = Traj_StatusError      // Traj_Status = 3
        Error = 2
        CMD"A"
        Dwell 0
        PVT_Time = 1000
    }


Return



N108: // Zero
    A_Vel = 0
    B_Vel = 0
    C_Vel = 0
    U_Vel = 0
    V_Vel = 0
    W_Vel = 0
    X_Vel = 0
    Y_Vel = 0
    Z_Vel = 0
Return


// Subroutine 9 ************************************************************************************
// Move axes
// *************************************************************************************************

N110:
    if (Axes > 0) {
        PVT (PVT_Time * 0.001)                    // Set move time
        GoSub111
    }
    TotalPoints = TotalPoints + 1
    If(UserFunc > 0) {
        GoSub(UserFunc)                     // Run any required subroutine
    }
Return

N111:
    A(Current_A):(A_Vel) B(Current_B):(B_Vel) C(Current_C):(C_Vel) U(Current_U):(U_Vel) V(Current_V):(V_Vel) W(Current_W):(W_Vel) X(Current_X):(X_Vel) Y(Current_Y):(Y_Vel) Z(Current_Z):(Z_Vel)
Return


// User Subroutines ********************************************************************************
// Subroutines to be used via the user buffer
// First 8 are for GPIO 1-3 combinations of on and off
// *************************************************************************************************

N1:
    M34 == 0 M33 == 0 M32 == 1
Return
N2:
    M34 == 0 M33 == 1 M32 == 0
Return
N3:
    M34 == 0 M33 == 1 M32 == 1
Return
N4:
    M34 == 1 M33 == 0 M32 == 0
Return
N5:
    M34 == 1 M33 == 0 M32 == 1
Return
N6:
    M34 == 1 M33 == 1 M32 == 0
Return
N7:
    M34 == 1 M33 == 1 M32 == 1
Return
N8:
    M34 == 0 M33 == 0 M32 == 0
Return

close